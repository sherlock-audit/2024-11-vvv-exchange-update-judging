Damaged Banana Raccoon

Medium

# EIP712 Compliance issue

### Summary

The contracts `VVVVCTokenDistributor` and `VVVVCInvestmentLedger` do not fully comply with EIP-712 specification for array handling. While the current implementation uses abi.encode which prevents common array manipulation attacks, the non-compliance with EIP-712 encoding rules could cause compatibility issues with wallets and signers that strictly implement the standard.


### Root Cause

https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/main/vvv-platform-smart-contracts/contracts/vc/VVVVCInvestmentLedger.sol#L213
https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/main/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L158
The contracts implement array encoding without following EIP-712's explicit requirements for handling arrays. According to EIP-712, arrays should have their own type definitions and each array element should be encoded recursively following the specification's encoding rules.
According to EIP712, the encoding of array should be done like this before hashing the struct data:
The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents (i.e. the encoding of SomeType[5] is identical to that of a struct containing five members of type SomeType).
Read More: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata
this isn't the case for _params.projectTokenProxyWallets, _params.tokenAmountsToClaim ...

### Internal pre-conditions

The contract calculates the EIP-712 digest using abi.encode for the full struct, including arrays.
Off-chain signers (e.g., dApps) expect EIP-712-compliant hashing, including hashing arrays element-by-element.

### External pre-conditions

An off-chain signature is generated by a tool (e.g., ethers.js or web3.js) that follows strict EIP-712 compliance rules.
The contract’s non-compliance causes discrepancies in the computed digest, leading to failed signature verifications.

### Attack Path

This is not a direct attack vector, but it creates massive operational issues:

A dApp or user generates a signature for a ClaimParams struct off-chain using an EIP-712-compliant library.
The signature is submitted to the claim function along with other parameters.
The contract’s implementation computes the digest using non-compliant array hashing, resulting in a mismatch with the off-chain digest.
The signature verification fails, preventing valid claims from being processed.


### Impact

Non-compliance with EIP-712 can result in the following:

Operational Failures: Signatures generated off-chain may fail to validate on-chain, preventing legitimate users from claiming their tokens.
Interoperability Issues: EIP-712-compliant tools, such as Metamask or ethers.js, may generate incompatible signatures, reducing the utility of the contract.
Reputation Risk: Users and integrators may perceive the contract as unreliable or improperly designed.

### PoC

All of the link mentioned above.  Also read this https://ethereum.stackexchange.com/questions/125105/signing-an-array-whit-eth-signtypeddata-v4

### Mitigation

Use `keccak256` hash of the arrays before constructing the struct hash.
