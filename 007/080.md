Fancy Fern Trout

Medium

# Incorrect encoding of uint256[] and address[] for EIP712 digest causes signatures generated by EIP712 common tools to be unusable

### Summary

The signature used in [claim()](https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/main/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L106) is generated based on the a digest computed from the  `ClaimParams`. However the  `projectTokenProxyWallets` and `tokenAmountsToClaim` are incorrectly encoded according to the EIP712 specification. So, signatures generated using common EIP712 tools would not pass the validation in [_isSignatureValid()](https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/main/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L157).

### Root Cause

By [definition](https://eips.ethereum.org/EIPS/eip-712#definition-of-typed-structured-data-%F0%9D%95%8A):
>The atomic types are bytes1 to bytes32, uint8 to uint256, int8 to int256, bool and address.
The reference types are arrays and structs. Arrays are either fixed size or dynamic and denoted by Type[n] or Type[] respectively. 

And according to the [EIP712's definition of `encodedData` ]():
>The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents (i.e. the encoding of SomeType[5] is identical to that of a struct containing five members of type SomeType). 

However, in the `VVVVCTokenDistributor` they are encoded as atomic instead of reference types.
```solidity
function _isSignatureValid(ClaimParams memory _params) private view returns (bool) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        CLAIM_TYPEHASH,
                        _params.kycAddress,
                        _params.projectTokenAddress,
@>                      _params.projectTokenProxyWallets,
@>                      _params.tokenAmountsToClaim,
                        _params.nonce,
                        _params.deadline
                    )
                )
            )
        );

        address recoveredAddress = ECDSA.recover(digest, _params.signature);

        bool isSigner = recoveredAddress == signer;
        bool isExpired = block.timestamp > _params.deadline;
        return isSigner && !isExpired;
    }
```

### Internal pre-conditions

_No response_

### External pre-conditions

_No response_

### Attack Path

_No response_

### Impact

A signature generated using common EIP712 tools would not pass the signature check in [claim()](https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/main/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L119).

### PoC

1. EIP712 signature computed using ethers.js
```javascript
// main.js
const { ethers } = require("ethers");

async function main() {
    const pk = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
    const signer = new ethers.Wallet(pk);
    const domain = {
        name: "VVVdevelopment",
        chainId: 31337,
        verifyingContract: "0xE82f6BD9565612CE7A960f5e0855BE68f9fEB58c" // should match the address in foundry test
    };
    const types = {
        ClaimParams: [
            { name: "kycAddress", type: "address" },
            { name: "projectTokenAddress", type: "address" },
            { name: "projectTokenProxyWallets", type: "address[]" },
            { name: "tokenAmountsToClaim", type: "uint256[]" },
            { name: "nonce", type: "uint256" },
            { name: "deadline", type: "uint256" }
        ],
    };
    const value = {
        kycAddress: "0x059F6b2a6620c9E07aec6Cca364B7110F8029db9",
        projectTokenAddress: "0x04a19Aaae62Aa4603aB4240E92D2639AC90999eA",
        projectTokenProxyWallets: ["0x109136A644e106eC22988c23c38bA83714991512"],
        tokenAmountsToClaim: ["1111000000000000000000"],
        nonce: "1",
        deadline: "3601"
    };
    const signature = await signer.signTypedData(domain, types, value);
    console.log(signature);
}

main();
```
The output is: 
`0x007380ff5400453ba8b7cdda06a84fa860fad83a9afe825ca0f1786964d89c114ebd4cbb07c93bc15993610d2a32fa50eebb20f500d4cc34a477cd6fde6e93631b`

2. EIP712 signature using foundry - the first function is the current implementation and the second is the corrected one.
```solidity
//SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {VVVVCTokenDistributorUnitTests} from "./VVVVCTokenDistributor.unit.t.sol";
import {VVVVCTokenDistributor} from "contracts/vc/VVVVCTokenDistributor.sol";
import {console} from "forge-std/console.sol";

contract PoC is VVVVCTokenDistributorUnitTests {
    function testPoC() public {
        address[] memory thisProjectTokenProxyWallets = new address[](1);
        thisProjectTokenProxyWallets[0] = 0x109136A644e106eC22988c23c38bA83714991512;
        uint256[] memory thisTokenAmountsToClaim = new uint256[](1);
        thisTokenAmountsToClaim[0] = 1111000000000000000000;

        VVVVCTokenDistributor.ClaimParams memory params = VVVVCTokenDistributor.ClaimParams({
            kycAddress: 0x059F6b2a6620c9E07aec6Cca364B7110F8029db9,
            projectTokenAddress: 0x04a19Aaae62Aa4603aB4240E92D2639AC90999eA,
            projectTokenProxyWallets: thisProjectTokenProxyWallets,
            tokenAmountsToClaim: thisTokenAmountsToClaim,
            nonce: 1,
            deadline: 3601,
            signature: bytes("placeholder")
        });
        uint256 signer = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;

        console.log("The current signature implementation: ");
        console.logBytes(
            getEIP712SignatureForClaimIncorrect(
                TokenDistributorInstance.DOMAIN_SEPARATOR(), TokenDistributorInstance.CLAIM_TYPEHASH(), params, signer
            )
        );

        console.log("The correct signature implementation: ");
        console.logBytes(
            getEIP712SignatureForClaimCorrect(
                TokenDistributorInstance.DOMAIN_SEPARATOR(), TokenDistributorInstance.CLAIM_TYPEHASH(), params, signer
            )
        );
    }

    function getEIP712SignatureForClaimIncorrect(
        bytes32 _domainSeparator,
        bytes32 _claimTypehash,
        VVVVCTokenDistributor.ClaimParams memory _params,
        uint256 signerKey
    ) public view returns (bytes memory) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                _domainSeparator,
                keccak256(
                    abi.encode(
                        _claimTypehash,
                        _params.kycAddress,
                        _params.projectTokenAddress,
                        _params.projectTokenProxyWallets,
                        _params.tokenAmountsToClaim,
                        _params.nonce,
                        _params.deadline
                    )
                )
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerKey, digest);
        bytes memory signature = toBytesConcat(r, s, v);

        return signature;
    }

    function getEIP712SignatureForClaimCorrect(
        bytes32 _domainSeparator,
        bytes32 _claimTypehash,
        VVVVCTokenDistributor.ClaimParams memory _params,
        uint256 signerKey
    ) public view returns (bytes memory) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                _domainSeparator,
                keccak256(
                    abi.encode(
                        _claimTypehash,
                        _params.kycAddress,
                        _params.projectTokenAddress,
                        keccak256(abi.encodePacked(_params.projectTokenProxyWallets)),
                        keccak256(abi.encodePacked(_params.tokenAmountsToClaim)),
                        _params.nonce,
                        _params.deadline
                    )
                )
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerKey, digest);
        bytes memory signature = toBytesConcat(r, s, v);

        return signature;
    }
}
```
The output is:
```logs
  The current signature implementation: 
  0xfb510040fbfb9029f18ebf53f06b9416b7047c22601151738374ad3f1252edc673c1ee41b36376f34abb98c806ae825caa24481f4d76eed0c33064560b2aaac11c
  The correct signature implementation: 
  0x007380ff5400453ba8b7cdda06a84fa860fad83a9afe825ca0f1786964d89c114ebd4cbb07c93bc15993610d2a32fa50eebb20f500d4cc34a477cd6fde6e93631b
```

From the logs above is visible that the signature, generated with the corrected implementation, matches the one generated with ethersjs.

### Mitigation

```diff
function _isSignatureValid(ClaimParams memory _params) private view returns (bool) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        CLAIM_TYPEHASH,
                        _params.kycAddress,
                        _params.projectTokenAddress,
-                       _params.projectTokenProxyWallets,
-                       _params.tokenAmountsToClaim,
+                       keccak256(abi.encodePacked(_params.projectTokenProxyWallets)),
+                       keccak256(abi.encodePacked(_params.tokenAmountsToClaim)),
                        _params.nonce,
                        _params.deadline
                    )
                )
            )
        );

        address recoveredAddress = ECDSA.recover(digest, _params.signature);

        bool isSigner = recoveredAddress == signer;
        bool isExpired = block.timestamp > _params.deadline;
        return isSigner && !isExpired;
    }
```